/**
 * Generator TypeScript SDK
 */

import * as fs from 'fs';
import * as path from 'path';
import { EndpointInfo, OpenAPISpec, GenerationOptions } from './types';
import { schemaToType, generateParamsInterface, generateRequestBodyType, generateResponseType } from './schema-to-types';
import { extractEndpoints } from './openapi-parser';

/**
 * Generate all interfaces from OpenAPI components
 */
function generateInterfacesFromComponents(spec: OpenAPISpec): string {
  const interfaces: string[] = [];
  
  if (spec.components?.schemas) {
    for (const [name, schema] of Object.entries(spec.components.schemas)) {
      const typeStr = schemaToType(schema as any);
      
      // Determine if this is an interface or a type
      const isComplex = typeStr.includes('\n');
      
      if (isComplex) {
        interfaces.push(`export interface ${name} ${typeStr}\n`);
      } else {
        interfaces.push(`export type ${name} = ${typeStr};\n`);
      }
    }
  }
  
  return interfaces.join('\n');
}

/**
 * Generate code for one endpoint
 */
function generateEndpointCode(endpoint: EndpointInfo, axiosInstance = 'axios'): string {
  const { path, method, operationId, pathParams, queryParams, requestBody, responses } = endpoint;
  
  // Generate function name
  const functionName = operationId;
  
  // Generate interfaces for parameters
  const pathParamsInterface = pathParams.length > 0 
    ? `${functionName}PathParams` 
    : 'never';
  const queryParamsInterface = queryParams.length > 0 
    ? `${functionName}QueryParams` 
    : 'never';
  
  // Generate type for request body
  const requestBodyType = requestBody 
    ? `${functionName}RequestBody` 
    : 'never';
  
  // Determine successful response (200, 201, etc.)
  const successStatus = Object.keys(responses).find(s => s.startsWith('2')) || '200';
  const successResponse = responses[successStatus];
  const responseType = generateResponseType(successResponse, functionName, successStatus);
  
  // Generate path with parameter substitution
  let urlPath = path;
  pathParams.forEach(param => {
    urlPath = urlPath.replace(`{${param.name}}`, `\${params.path.${param.name}}`);
  });
  
  // Generate function code
  let paramsType = '{';
  if (pathParams.length > 0) paramsType += `\n    path: ${pathParamsInterface};`;
  if (queryParams.length > 0) paramsType += `\n    query?: ${queryParamsInterface};`;
  if (requestBody) paramsType += `\n    body: ${requestBodyType};`;
  paramsType += '\n  }';
  
  const urlGeneration = `const url = \`${urlPath}\`;`;
  const queryString = queryParams.length > 0 
    ? `const queryString = params.query ? '?' + new URLSearchParams(params.query as any).toString() : '';`
    : '';
  const finalUrl = queryParams.length > 0 
    ? `const finalUrl = url + queryString;`
    : `const finalUrl = url;`;
  
  const bodyParam = requestBody ? 'params.body' : '';
  
  return `
${generateParamsInterface(pathParams, queryParams, functionName)}

${requestBody ? generateRequestBodyType(requestBody, functionName) : ''}

export async function ${functionName}(params: ${paramsType}): Promise<${responseType}> {
  ${urlGeneration}
  ${queryString}
  ${finalUrl}
  
  const response = await ${axiosInstance}.${method.toLowerCase()}<${responseType}>(
    finalUrl${bodyParam ? `, ${bodyParam}` : ''}
  );
  
  return response.data;
}
`;
}

/**
 * Generate full SDK from specifications
 */
export async function generateSDK(specs: OpenAPISpec[], options: GenerationOptions): Promise<void> {
  const outputDir = options.outputDir;
  
  // Create directory for output
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Collect all endpoints from all specifications
  const allEndpoints: EndpointInfo[] = [];
  const allInterfaces: string[] = [];
  
  for (const spec of specs) {
    const endpoints = extractEndpoints(spec);
    allEndpoints.push(...endpoints);
    
    const interfaces = generateInterfacesFromComponents(spec);
    if (interfaces) {
      allInterfaces.push(interfaces);
    }
  }
  
  // Generate all interfaces
  const interfacesContent = allInterfaces.join('\n\n');
  
  // Generate code for all endpoints
  const endpointsCode = allEndpoints
    .map(endpoint => generateEndpointCode(endpoint, options.axiosInstance))
    .join('\n');
  
  // Генерируем основной файл SDK
  const sdkContent = `/**
 * Automatically generated TypeScript SDK
 * Do not edit this file manually
 */

import ${options.axiosInstance || 'axios'} from 'axios';

${interfacesContent}

${endpointsCode}
`;
  
  // Write SDK
  fs.writeFileSync(path.join(outputDir, 'sdk.ts'), sdkContent);
  
  // Generate index.ts for export
  const indexContent = `export * from './sdk';
`;
  
  fs.writeFileSync(path.join(outputDir, 'index.ts'), indexContent);
  
  // Generate package.json for SDK
  const packageJson = {
    name: 'generated-sdk',
    version: '1.0.0',
    main: 'index.js',
    types: 'index.d.ts',
    dependencies: {
      axios: '^1.6.0'
    }
  };
  
  fs.writeFileSync(
    path.join(outputDir, 'package.json'),
    JSON.stringify(packageJson, null, 2)
  );
  
  // Generate tsconfig.json for SDK
  const tsconfig = {
    compilerOptions: {
      target: 'ES2020',
      module: 'commonjs',
      lib: ['ES2020'],
      declaration: true,
      outDir: './dist',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true
    },
    include: ['*.ts'],
    exclude: ['node_modules', 'dist']
  };
  
  fs.writeFileSync(
    path.join(outputDir, 'tsconfig.json'),
    JSON.stringify(tsconfig, null, 2)
  );
}

